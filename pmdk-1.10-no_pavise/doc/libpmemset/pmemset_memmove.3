.\" Automatically generated by Pandoc 1.19.2.4
.\"
.TH "" "" "2022-08-10" "PMDK - " "PMDK Programmer's Manual"
.hy
.\" SPDX-License-Identifier: BSD-3-Clause
.\" Copyright 2021, Intel Corporation
.SH NAME
.PP
\f[B]pmemset_memmove\f[](), \f[B]pmemset_memcpy\f[](),
\f[B]pmemset_pmemset\f[]() \- performs memmove/memcpy/memset on memory
from the \f[I]pmemset\f[].
.SH SYNOPSIS
.IP
.nf
\f[C]
#include\ <libpmemset.h>

void\ *pmemset_memmove(struct\ pmemset\ *set,\ void\ *pmemdest,\ const\ void\ *src,
\ \ \ \ \ \ \ \ size_t\ len,\ unsigned\ flags);

void\ *pmemset_memcpy(struct\ pmemset\ *set,\ void\ *pmemdest,\ const\ void\ *src,
\ \ \ \ \ \ \ \ size_t\ len,\ unsigned\ flags);

void\ *pmemset_memset(struct\ pmemset\ *set,\ void\ *pmemdest,\ int\ c,\ size_t\ len,
\ \ \ \ \ \ \ \ unsigned\ flags);
\f[]
.fi
.SH DESCRIPTION
.PP
The \f[B]pmemset_memmove\f[](), \f[B]pmemset_memcpy\f[]() and
\f[B]pmemset_memset\f[]() functions provide the same memory copying
functionalities as their namesakes \f[B]memmove\f[](3),
\f[B]memcpy\f[](3) and \f[B]memset\f[](3), and ensure that the result
has been flushed to persistence before returning (unless
\f[B]PMEM2_F_MEM_NOFLUSH\f[] flag was used).
.PP
For example, the following code:
.IP
.nf
\f[C]
\ \ \ \ \ \ \ \ memmove(dest,\ src,\ len);
\ \ \ \ \ \ \ \ pmemset_persist(set,\ dest,\ len);
\f[]
.fi
.PP
is functionally equivalent to:
.IP
.nf
\f[C]
\ \ \ \ \ \ \ \ pmemset_memmove(set,\ dest,\ src,\ len,\ 0);
\f[]
.fi
.PP
Unlike libc implementation, \f[B]libpmemset\f[] functions guarantee that
if destination buffer address and length are 8 byte aligned then all
stores will be performed using at least 8 byte store instructions.
This means that a series of 8 byte stores followed by
\f[I]pmemset_persist\f[] can be safely replaced by a single
\f[I]pmemset_memmove\f[] call.
.PP
The \f[I]flags\f[] argument of all of the above functions has the same
meaning.
It can be 0 or a bitwise OR of one or more of the following flags:
.IP \[bu] 2
\f[B]PMEMSET_F_MEM_NODRAIN\f[] \- modifies the behavior to skip the
final \f[I]pmemset_drain\f[] step.
This allows applications to optimize cases where several ranges are
being copied to persistent memory, followed by a single call to
\f[B]pmemset_drain\f[](3).
The following example illustrates how this flag might be used to avoid
multiple calls to \f[B]pmemset_drain\f[](3) when copying several ranges
of memory to pmem:
.IP
.nf
\f[C]
/*\ ...\ write\ several\ ranges\ to\ pmem\ ...\ */
pmemset_memcpy(set,\ pmemdest1,\ src1,\ len1,\ PMEMSET_F_MEM_NODRAIN);
pmemset_memcpy(set,\ pmemdest2,\ src2,\ len2,\ PMEMSET_F_MEM_NODRAIN);

/*\ ...\ */

/*\ wait\ for\ any\ pmem\ stores\ to\ drain\ from\ HW\ buffers\ */
pmemset_drain(set);
\f[]
.fi
.IP \[bu] 2
\f[B]PMEMSET_F_MEM_NOFLUSH\f[] \- Don\[aq]t flush anything.
This implies \f[B]PMEMSET_F_MEM_NODRAIN\f[].
Using this flag only makes sense when it\[aq]s followed by any function
that flushes data.
.PP
The remaining flags say \f[I]how\f[] the operation should be done, and
are merely hints.
.IP \[bu] 2
\f[B]PMEMSET_F_MEM_NONTEMPORAL\f[] \- Use non\-temporal instructions.
This flag is mutually exclusive with \f[B]PMEMSET_F_MEM_TEMPORAL\f[].
On x86_64 this flag is mutually exclusive with
\f[B]PMEMSET_F_MEM_NOFLUSH\f[].
.IP \[bu] 2
\f[B]PMEMSET_F_MEM_TEMPORAL\f[] \- Use temporal instructions.
This flag is mutually exclusive with \f[B]PMEMSET_F_MEM_NONTEMPORAL\f[].
.IP \[bu] 2
\f[B]PMEMSET_F_MEM_WC\f[] \- Use write combining mode.
This flag is mutually exclusive with \f[B]PMEMSET_F_MEM_WB\f[].
On x86_64 this flag is mutually exclusive with
\f[B]PMEMSET_F_MEM_NOFLUSH\f[].
.IP \[bu] 2
\f[B]PMEMSET_F_MEM_WB\f[] \- Use write back mode.
This flag is mutually exclusive with \f[B]PMEMSET_F_MEM_WC\f[].
On x86_64 this is an alias for \f[B]PMEMSET_F_MEM_TEMPORAL\f[].
.PP
Using an invalid combination of flags has undefined behavior.
.PP
Without any of the above flags \f[B]libpmemset\f[] will try to guess the
best strategy based on the data size.
See \f[B]PMEM_MOVNT_THRESHOLD\f[] description in \f[B]libpmem2\f[](7)
for details.
.SH RETURN VALUE
.PP
The \f[B]pmemset_memmove\f[](), \f[B]pmemset_memset\f[](),
\f[B]pmemset_memcpy\f[]() function returns a pointer to the memory area
\f[I]pmemdest\f[] in the same way as their namesakes
\f[B]memmove\f[](3), \f[B]memcpy\f[](3) and \f[B]memset\f[](3).
.SH SEE ALSO
.PP
\f[B]memcpy\f[](3), \f[B]memmove\f[](3), \f[B]memset\f[](3),
\f[B]pmemset_drain\f[](3), \f[B]pmemset_persist\f[](3),
\f[B]libpmem2\f[](7), \f[B]libpmemset\f[](7) and
\f[B]<https://pmem.io>\f[]
